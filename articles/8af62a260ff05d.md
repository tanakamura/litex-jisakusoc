---
title: "xsave"
emoji: "ğŸ¦”"
type: "tech"
topics: ["AVX","x86","SIMD","AVX512"]
published: true
---

(ä»¥ä¸‹ã¯èª¿ã¹ãªãŒã‚‰æ›¸ã„ãŸã®ã§ã€èª­ã¿ã¥ã‚‰ã„ã§ã™ https://zenn.dev/tanakmura/articles/8af62a260ff05d ã¡ã‚ƒã‚“ã¨èª¿ã¹ã¦ã‹ã‚‰æ›¸ã„ãŸç‰ˆãŒã‚ã‚Šã¾ã™)

# AVXã¨ãƒ¬ã‚¸ã‚¹ã‚¿ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ

AVXç™»å ´ã‚ˆã‚Šå‰ã¯ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¹ã‚¤ãƒƒãƒã®FPUãƒ¬ã‚¸ã‚¹ã‚¿ä¿å­˜æ™‚ã«ä¿å­˜ã™ã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã‚»ãƒƒãƒˆã«ã‚ã‚ã›ã¦å‘½ä»¤ã‚’é§†ä½¿ã—ã¦ã„ãŸã€‚

æœ€çµ‚çš„ã«SSEãƒ¬ã‚¸ã‚¹ã‚¿ä¿å­˜æ™‚ã«ã¯ã€fxsave/fxrstor ã¨ã„ã†å‘½ä»¤ã‚’ä½¿ã†ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹(ã¨æ€ã†)ã€‚

fxsave/fxrstor ã¯ã€å›ºå®šãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ FPU, MMX, SSE ã®çŠ¶æ…‹ã‚’ä¿å­˜ã€å¾©å…ƒã™ã‚‹ã€‚

![](https://storage.googleapis.com/zenn-user-upload/9535613ccbf3-20211212.png)

(IntelÂ® 64 and IA-32 Architectures Software Developerâ€™s Manual Volume 1: Basic Architecture ã‚ˆã‚Š)

fxsave/fxrstorã¯ã€ãƒ¬ã‚¸ã‚¹ã‚¿ã®æ•°ã‚„ã‚µã‚¤ã‚ºãŒå¤‰ã‚ã‚‹ã”ã¨ã«å‘½ä»¤ã‚’è¿½åŠ ã—ãªã„ã¨ã„ã‘ãªã„ã¨ã„ã†å•é¡Œã‚’æŠ±ãˆã¦ã„ã‚‹ã€‚

å®Ÿéš›ã€ã“ã‚Œã¯AVXã«å¯¾å¿œã—ã¦ã„ãªã„ã—ã€ã•ã‚‰ã«ãã®ä¸Šã«AVX-512ãŒä¹—ã‚‹ã¨ã€ã•ã‚‰ã«å‘½ä»¤è¿½åŠ ã—ãªã„ã¨ã„ã‘ãªã„ã€‚ã•ã‚‰ã«è¨€ã†ã¨ã€ç¾æ™‚ç‚¹ã§æ—¢ã«AMXã¨ã„ã†ã•ã‚‰ã«è¿½åŠ ã®æ‹¡å¼µãŒå…¥ã‚‹ã“ã¨ã‚‚æ±ºã¾ã£ã¦ã„ã‚‹ã€‚


ã“ã®ã¸ã‚“ã®å•é¡Œã‚’æ•´ç†ã—ã€FPUãƒ¬ã‚¸ã‚¹ã‚¿ã®ä¿å­˜ã€å¾©å…ƒã‚’æ‹…ã†å‘½ä»¤ãŒã€xsave/xrstor ã§ã‚ã‚‹ã€‚


xsave/xrstor ã¯ã€fxsave ã®å‹•ä½œã«åŠ ãˆã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ‹¡å¼µã•ã‚ŒãŸãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ä¿å­˜ã™ã‚‹ã€‚

- ä½•ãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’ç¤ºã™ XSAVE Header ã‚’ä¿å­˜ã™ã‚‹
- ä¿å­˜ã™ã‚‹ã‚‚ã®ã¯å›ºå®šã§ã¯ãªãã€XCR0 ã¨ã„ã†ãƒ¬ã‚¸ã‚¹ã‚¿ã§æŒ‡å®šã•ã‚ŒãŸã‚‚ã®ã‚’ä¿å­˜ã™ã‚‹

ã“ã‚Œã«ã‚ˆã£ã¦ã€AVXã€AVX-512ã€AMX (ã‚ã¨ä»Šã¯äº¡ãMPX) ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ä¿å­˜ã§ãã‚‹å‘½ä»¤ã«ãªã£ã¦ã„ã‚‹ã€‚

ä¿å­˜ã™ã‚‹ã‚‚ã®ã‚’æŒ‡å®šã™ã‚‹XCR0ã®ãƒ“ãƒƒãƒˆã¯ã¾ã ä½™ã£ã¦ã„ã¦ã€ã•ã‚‰ã«ãã®å…ˆã®æ‹¡å¼µãŒã‚ã£ãŸã¨ãã«ã‚‚ã—ã°ã‚‰ãã¯å¯¾å¿œã§ãã‚‹ã€‚

(ã¨ã„ã†ã»ã©ç°¡å˜ã§ã¯ãªãã€sigaltstack ã‚’ä½¿ã†ã¨ãã®ã‚¹ã‚¿ãƒƒã‚¯ã‚µã‚¤ã‚ºã¨ã—ã¦ã‚ˆãä½¿ã‚ã‚Œã¦ã„ãŸSIGSTKSZ https://www.gnu.org/software/libc/manual/html_node/Signal-Stack.html ã¯ 8KiB ã—ã‹ãªãã€AMXã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ä¿å­˜ã§ããªã„ã®ã§ãƒ—ãƒ­ã‚»ã‚¹èµ·å‹•å¾Œã¯AMXãŒä½¿ãˆãªã„ã¨ã„ã†å•é¡ŒãŒç™ºç”Ÿã—ã¦ã„ãŸã‚Šã™ã‚‹ã€‚Linuxç’°å¢ƒã§ã®è©±ã«ã¤ã„ã¦ã¯æ¬¡å›(ã„ã¤ï¼Ÿ)æ›¸ã)


## xsave/xrstor

ã¾ãšã¯xsaveã‚’ä½¿ã£ã¦ã¿ã‚‹ã€‚

xsave ã§ä¿å­˜ã™ã¹ãæƒ…å ±ã¯ã€XCR0 ã¨ã„ã†ãƒ¬ã‚¸ã‚¹ã‚¿ã«å…¥ã£ã¦ã„ã¦ã€ã“ã‚Œã‚’èª­ã‚ã°ã€ä½•ã‚’ä¿å­˜ã—ãªã„ã¨ã„ã‘ãªã„ã‹ãŒã‚ã‹ã‚‹ã€‚

XCR0 ã¯ã€xgetbvã«0ã‚’æŒ‡å®šã™ã‚Œã°å–ã‚Œã‚‹

```cpp
#include <immintrin.h>
#include <stdio.h>
#include <stdint.h>

int main() {
    uint64_t xcr0 = _xgetbv(0);
    printf("xcr0 = %016llx\n", (long long)xcr0);
}
```


```sh
$ gcc -mavx xsave_xcr0.cpp  # -mavx ãŒã„ã‚‹

# AVX-512ãŒç„¡ã„å ´åˆ
$ ./a.out 
xcr0 = 0000000000000207

# AVX-512ãŒã‚ã‚‹å ´åˆ (XCR0ãŒAVX-512ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ä¿å­˜ã—ãªã„ã¨ã„ã‘ãªã„ã“ã¨ã‚’ç¤ºã—ã¦ã„ã‚‹)
$ ./a.out
xcr0 = 00000000000002e7
```


ã“ã®ã€XCR0 ã®å„ãƒ“ãƒƒãƒˆã¯ã€ä¿å­˜ã™ã¹ããƒ¬ã‚¸ã‚¹ã‚¿ã‚»ãƒƒãƒˆã‚’ç¤ºã—ã¦ã„ã¦ã€

| bitpos | ãƒ¬ã‚¸ã‚¹ã‚¿ |
| ------ | -------- |
| 0      | x87 (+MMX)     |
| 1      | SSE      |
| 2      | AVX     |
| 3      | ä»Šã¯äº¡ãMPX     |
| 4      | ä»Šã¯äº¡ãMPX     |
| 5      | AVX-512 opmask (k0-k7ã®ã“ã¨) |
| 6      | AVX-512 ZMM0-15 ã®ä¸Šä½ |
| 7      | AVX-512 ZMM16-31 |
| 8      | PT (Processor Trace ã®ä½•ã‹) |
| 9      | PKRU (çŸ¥ã‚‰ã‚“) |
| 11     | CET |
| 12     | CET |
| 13     | HDC (çŸ¥ã‚‰ã‚“) |
| 16     | HWp (çŸ¥ã‚‰ã‚“) |
| 17     | AMX ã® XTILECFG |
| 18     | AMX ã® XTILEDATA |

ã¨ãªã£ã¦ã„ã‚‹ã€‚

AVXã‚ˆã‚Šã‚ã¨ã®å„é ˜åŸŸã®ã‚µã‚¤ã‚ºã¯ã€CPUID ã§å–ã£ã¦ã“ã‚Œã‚‹ã€‚ (x87 ã¨ SSE ã¯å›ºå®šãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãªã®ã§ã€ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚’è¦‹ã¦èª¿ã¹ã‚‹)


```cpp
#include <cpuid.h>
#include <immintrin.h>
#include <stdio.h>
#include <string.h>

#include <string>
#include <vector>

struct ContextEntry {
    ContextEntry(int bitpos, std::string const &name)
        : bitpos(bitpos), name(name) {}

    int bitpos;
    std::string name;

    int bytepos = 0;
    int bytesize = 0;
    bool available = false;
};

std::vector<struct ContextEntry> offset_table = {
    {0, "x87"},
    {1, "SSE"},
    {2, "AVX"},
    {3, "MPX BNDREGS"},
    {4, "MPX BNDCSR"},
    {5, "AVX512 opmask"},
    {6, "AVX512 ZMM_Hi256"},
    {7, "AVX512 Hi16_ZMM"},
    {8, "PT"},
    {9, "PKRU"},
    // {10, 0, 0, "reserved"},
    {11, "CET_U"},
    {12, "CET_S"},
    {13, "HDC"},
    // {14, 0, "??"},
    // {15, 0, "reserved"},
    {16, "HWP"},

    /* amx */
    {17, "XTILECFG"},
    {18, "XTILEDATA"},
};

static int xsave_fullsize;

static void init_offset() {
    uint64_t xcr0 = _xgetbv(0);
    for (auto &&e : offset_table) {
        if (xcr0 & (1ULL << e.bitpos)) {
            unsigned int eax, ebx, ecx, edx;
            __cpuid_count(0x0d, e.bitpos, eax, ebx, ecx, edx);

            if (e.bitpos == 0) {
                // x87
                xsave_fullsize = ebx;
                e.bytepos = 0;
                e.bytesize = 160;
                e.available = true;
            } else if (e.bitpos == 1) {
                // sse
                e.bytepos = 160;
                e.bytesize = 16 * 16;
                e.available = true;

            } else {
                e.bytepos = ebx;
                e.bytesize = eax;
                e.available = true;
            }
        }
    }

    printf("xsave context size = %d\n", xsave_fullsize);

    for (auto &&e : offset_table) {
        if (e.available) {
            printf("%16s (%4d): offset=%d, size=%d\n", e.name.c_str(), e.bitpos,
                   e.bytepos, e.bytesize);
        }
    }
}

static void *alloc(size_t sz) {
    void *p;
    posix_memalign(&p, 64, sz);
    return p;
}

int main() {
    init_offset();

    char *area = (char*)alloc(xsave_fullsize);
    memset(area, 0, xsave_fullsize);

    /* ååˆ†ãªã‚µã‚¤ã‚ºãŒã‚ã‚‹ */
    _xsave((void *)area, ~0ULL);
}
```

```sh
# AVX-512 ãªã— (alderlake)
$ ./a.out
xsave context size = 2696
             x87 (   0): offset=0, size=160
             SSE (   1): offset=160, size=256
             AVX (   2): offset=576, size=256
            PKRU (   9): offset=2688, size=8

# AVX-512 ã»ã‚“ã¨ã†ã«ãªã— (Kaby Lake)
$ ./a.out
xsave context size = 1088
             x87 (   0): offset=0, size=160
             SSE (   1): offset=160, size=256
             AVX (   2): offset=576, size=256
     MPX BNDREGS (   3): offset=960, size=64
      MPX BNDCSR (   4): offset=1024, size=64


# AVX-512 ã‚ã‚Š
$ ./a.out
xsave context size = 2696
             x87 (   0): offset=0, size=160
             SSE (   1): offset=160, size=256
             AVX (   2): offset=576, size=256
   AVX512 opmask (   5): offset=1088, size=64
AVX512 ZMM_Hi256 (   6): offset=1152, size=512
 AVX512 Hi16_ZMM (   7): offset=1664, size=1024
            PKRU (   9): offset=2688, size=8

```

ã“ã‚Œã‚’è¦‹ã‚Œã°ã€å›ºå®šã§ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚µã‚¤ã‚ºã‚’æ±ºã‚ãªãã¦ã‚ˆããªã‚‹ã®ã§ã€å°†æ¥æ‹¡å¼µãŒå…¥ã£ãŸå ´åˆã«ã‚‚é©åˆ‡ã«ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚


ã“ã‚Œã‚’ä½¿ã£ã¦ã¿ã‚ˆã†ã€‚gccãªã‚‰_xsave intrinsicsã‚’ä½¿ãˆã°ã€xsaveãŒã§ãã‚‹ã€‚
```cpp
#include <cpuid.h>
#include <immintrin.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <string>
#include <vector>

struct ContextEntry {
    ContextEntry(int bitpos, std::string const &name)
        : bitpos(bitpos), name(name) {}

    int bitpos;
    std::string name;

    int bytepos = 0;
    int bytesize = 0;
    bool available = false;
};

std::vector<struct ContextEntry> offset_table = {
    {0, "x87"},
    {1, "SSE"},
    {2, "AVX"},
    {3, "MPX BNDREGS"},
    {4, "MPX BNDCSR"},
    {5, "AVX512 opmask"},
    {6, "AVX512 ZMM_Hi256"},
    {7, "AVX512 Hi6_ZMM"},
    {8, "PT"},
    {9, "PKRU"},
    // {10, 0, 0, "reserved"},
    {11, "CET_U"},
    {12, "CET_S"},
    {13, "HDC"},
    // {14, 0, "??"},
    // {15, 0, "reserved"},
    {16, "HWP"},

    /* amx */
    {17, "XTILECFG"},
    {18, "XTILEDATA"},
};

ContextEntry &lookup_entry(int bitpos) {
    for (auto &&e : offset_table) {
        if (e.bitpos == bitpos) {
            if (!e.available) {
                puts("not available");
                abort();
            }
            return e;
        }
    }

    abort();
}

static int xsave_fullsize;

static void init_offset() {
    uint64_t xcr0 = _xgetbv(0);
    for (auto &&e : offset_table) {
        if (xcr0 & (1ULL << e.bitpos)) {
            unsigned int eax, ebx, ecx, edx;
            __cpuid_count(0x0d, e.bitpos, eax, ebx, ecx, edx);

            if (e.bitpos == 0) {
                // x87
                xsave_fullsize = ebx;
                e.bytepos = 0;
                e.bytesize = 160;
                e.available = true;
            } else if (e.bitpos == 1) {
                // sse
                e.bytepos = 160;
                e.bytesize = 16 * 16;
                e.available = true;

            } else {
                e.bytepos = ebx;
                e.bytesize = eax;
                e.available = true;
            }
        }
    }

    printf("xsave context size = %d\n", xsave_fullsize);

    for (auto &&e : offset_table) {
        if (e.available) {
            printf("%16s (%4d): offset=%d, size=%d\n", e.name.c_str(), e.bitpos,
                   e.bytepos, e.bytesize);
        }
    }
}

#define SET_YMM(off, v) \
    asm volatile("vmovdqu %0, %%ymm" #off ::"x"(v) : "ymm" #off);

#define GET_YMM(off, v) \
    asm volatile("vmovdqu %%ymm" #off ",%0" :"=x"(v) :: "ymm" #off);

void set_avx_reg(__m256i init) {
    SET_YMM(1, init);
    SET_YMM(2, init);
    SET_YMM(3, init);
    SET_YMM(4, init);
    SET_YMM(5, init);
    SET_YMM(6, init);
    SET_YMM(7, init);
    SET_YMM(8, init);
    SET_YMM(9, init);
    SET_YMM(10, init);
    SET_YMM(11, init);
    SET_YMM(12, init);
    SET_YMM(13, init);
    SET_YMM(14, init);
    SET_YMM(15, init);
}

static void *alloc(size_t sz) {
    void *p;
    posix_memalign(&p, 64, sz);
    return p;
}

static void dump_xsave_header(char *p) {
    uint64_t *header = (uint64_t *)(p + 512);

    printf("XSTATE_BV : %016llx\n", (long long)header[0]);
    printf("XCOMP_BV  : %016llx\n", (long long)header[1]);
}

int main() {
    init_offset();

    char *area = (char *)alloc(xsave_fullsize);
    memset(area, 0, xsave_fullsize);

    set_avx_reg(_mm256_set1_epi8(0xff));
    SET_YMM(14, _mm256_set1_epi8(0xaa));
    SET_YMM(15, _mm256_set_epi32(1, 2, 3, 4, 5, 6, 7, 8));

    _xsave((void *)area, ~0ULL);

    {
        auto &avx_lo_context = lookup_entry(1);  // AVX lo (SSE)
        uint64_t *avx_lo_region = (uint64_t *)(area + avx_lo_context.bytepos);

        auto &avx_hi_context = lookup_entry(2);  // AVX hi
        uint64_t *avx_hi_region = (uint64_t *)(area + avx_hi_context.bytepos);

        for (int i = 0; i < 16; i++) {
            printf("ymm%-2d : %016llx %016llx %016llx %016llx\n", i,
                   (long long)avx_hi_region[i * 2 + 1],
                   (long long)avx_hi_region[i * 2 + 0],
                   (long long)avx_lo_region[i * 2 + 1],
                   (long long)avx_lo_region[i * 2 + 0]);
        }
    }

    /* avx reg clear */
    set_avx_reg(_mm256_set1_epi8(0x0));

    /* å¾©å…ƒ */
    _xrstor((void *)area, ~0ULL);

    __m256i v;
    GET_YMM(15, v);

    printf("%016llx %016llx %016llx %016llx\n",
           _mm256_extract_epi64(v, 3),
           _mm256_extract_epi64(v, 2),
           _mm256_extract_epi64(v, 1),
           _mm256_extract_epi64(v, 0));

    return 0;
}
```

cpuid ã§å–ã‚Šå‡ºã—ãŸ xsave ã®çŠ¶æ…‹å†…ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‹ã‚‰å€¤ã‚’å–ã‚Šå‡ºã›ã°ã€avx ã®ãƒ¬ã‚¸ã‚¹ã‚¿ãŒå–å¾—ã§ãã¦ã„ã‚‹ã€‚(ymm14 ã¨ ymm15 ã«è¨­å®šã—ãŸå€¤ãŒè¦‹ãˆã¦ã„ã‚‹ã¯ãšã€‚ã“ã‚Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®æ°—æŒã¡ã«ã‚ˆã£ã¦å‹•ä½œãŒå¤‰ã‚ã‚‹ã®ã§ã€å‡ºãªã„ã‹ã‚‚ã—ã‚Œãªã„)

xsave ãŒä¿å­˜ã™ã‚‹å€¤ã¯ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã§æ±ºã‚ã‚‰ã‚Œã‚‹ã€‚_xsave ã®äºŒç•ªç›®ã®å¼•æ•°ãŒã€ä¿å­˜ã™ã‚‹ãƒ¬ã‚¸ã‚¹ã‚¿ã‚»ãƒƒãƒˆã‚’ç¤ºã—ã¦ã„ã¦ã€ã“ã‚Œã¨ XCR0 ã® and ã‚’å–ã£ãŸã‚‚ã®ãŒä¿å­˜ã•ã‚Œã‚‹ã€‚


xrstor ã¯ã€ãã®é€†ã®å‡¦ç†ã‚’ã™ã‚‹ã€‚

xsaveã¯ä¿å­˜ã™ã‚‹ã¨ãã«ã€ä½•ã‚’ä¿å­˜ã—ãŸã‹ã‚’XSTATE_BVã¨ã„ã†é ˜åŸŸã«ä¸€ç·’ã«è¨˜éŒ²ã—ã¦ã„ã‚‹ã€‚ã“ã‚Œã¯ä¿å­˜é ˜åŸŸã®å…ˆé ­ã‹ã‚‰512byteã«æ›¸ã‹ã‚Œã¦ã„ã¦ã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã€XCR0 ã¨åŒã˜ã«ãªã‚‹ã€‚

xrstor ã¯ã€ã“ã®XSTATE_BVã‚’è¦‹ã¦å¾©å…ƒã™ã¹ããƒ¬ã‚¸ã‚¹ã‚¿ã‚’æ±ºã‚ã‚‹ã€‚XSTATE_BVã«è¨˜éŒ²ã•ã‚Œã¦ã„ãªã„ãƒ¬ã‚¸ã‚¹ã‚¿ã¯åˆæœŸåŒ–ã•ã‚Œã‚‹ã€‚


## xsaveopt

AVX ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ã¨ã€XCR0 ã¯ã€AVX ãŒã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å«ã¾ã‚Œã‚‹ã‚ˆã†ã«è¨­å®šã•ã‚Œã‚‹ã€‚

AVX ã¯ã¾ã ã„ã„ãŒã€ã“ã‚ŒãŒ AVX-512 ã«ã‚‚ãªã‚‹ã¨ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã‚µã‚¤ã‚ºãŒ2KiB ã‚’è¶…ãˆã‚‹ã‚ˆã†ã«ãªã£ã¦ã€æ¯å›å…¨éƒ¨ä¿å­˜ã™ã‚‹ã®ã¯ã€åŠ¹ç‡ãŒã‚ˆããªã„ã€‚å¯èƒ½ãªã‚‰ã€ä½¿ã£ãŸãƒ¬ã‚¸ã‚¹ã‚¿ã ã‘ã‚’ä¿å­˜ã—ã¦ã»ã—ã„ã€‚

x86 ã¯ã€ä½¿ã‚ã‚ŒãŸãƒ¬ã‚¸ã‚¹ã‚¿ã‚»ãƒƒãƒˆã‚’ã€XINUSEã¨ã„ã†çŠ¶æ…‹ã«ä¿å­˜ã—ã¦ã„ã¦ã€ã“ã‚Œã®ãƒ“ãƒƒãƒˆãŒç«‹ã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’è¦‹ã¦ã€ä¿å­˜/å¾©å…ƒã™ã¹ããƒ¬ã‚¸ã‚¹ã‚¿ã‚»ãƒƒãƒˆã‚’è‡ªå‹•çš„ã«å‰Šæ¸›ã•ã›ã‚‹ã€xsaveopt ã¨ã„ã†å‘½ä»¤ã‚’ç”¨æ„ã—ã¦ã„ã‚‹ã€‚


XINUSEã®çŠ¶æ…‹ã¯ã€xgetbv ã® 1ç•ªã‹ã‚‰å–å¾—ã§ãã‚‹

```cpp
#include <cpuid.h>
#include <immintrin.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <string>
#include <vector>

#define SET_YMM(off, v) \
    asm volatile("vmovdqu %0, %%ymm" #off ::"x"(v) : "ymm" #off);

#define GET_YMM(off, v) \
    asm volatile("vmovdqu %%ymm" #off ",%0" :"=x"(v) :: "ymm" #off);

static void
dump_xcr0() {
    uint64_t xcr0 = _xgetbv(0);
    uint64_t xinuse = _xgetbv(1);

    printf("XCR0   : %016llx\n", xcr0);
    printf("XINUSE : %016llx\n", xinuse);
}

int main()
{
    dump_xcr0();

    SET_YMM(1, _mm256_set1_epi8(1));

    dump_xcr0();
}
```

```
$ ./a.out 
XCR0   : 0000000000000207
XINUSE : 0000000000000202
XCR0   : 0000000000000207
XINUSE : 0000000000000206 # AVXãŒä½¿ã‚ã‚ŒãŸ
```

xsaveopt ã¯ã€ã“ã‚Œã‚’è¦‹ã¦ä¿å­˜ã™ã¹ãã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æ±ºã‚ã€ã©ã‚Œã‚’ä¿å­˜ã—ãŸã‹ã‚’ãƒ¬ã‚¸ã‚¹ã‚¿ã¨ä¸€ç·’ã«ãƒ¡ãƒ¢ãƒªã«ä¿å­˜ã™ã‚‹ã€‚ã“ã‚Œã¯ã€XSAVE headerã¨å‘¼ã°ã‚Œã¦ã€xsave ãŒä¿å­˜ã—ãŸçŠ¶æ…‹ã®

```cpp
#include <cpuid.h>
#include <immintrin.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <string>
#include <vector>

struct ContextEntry {
    ContextEntry(int bitpos, std::string const &name)
        : bitpos(bitpos), name(name) {}

    int bitpos;
    std::string name;

    int bytepos = 0;
    int bytesize = 0;
    bool available = false;
};

std::vector<struct ContextEntry> offset_table = {
    {0, "x87"},
    {1, "SSE"},
    {2, "AVX"},
    {3, "MPX BNDREGS"},
    {4, "MPX BNDCSR"},
    {5, "AVX512 opmask"},
    {6, "AVX512 ZMM_Hi256"},
    {7, "AVX512 Hi6_ZMM"},
    {8, "PT"},
    {9, "PKRU"},
    // {10, 0, 0, "reserved"},
    {11, "CET_U"},
    {12, "CET_S"},
    {13, "HDC"},
    // {14, 0, "??"},
    // {15, 0, "reserved"},
    {16, "HWP"},

    /* amx */
    {17, "XTILECFG"},
    {18, "XTILEDATA"},
};

ContextEntry &lookup_entry(int bitpos) {
    for (auto &&e : offset_table) {
        if (e.bitpos == bitpos) {
            if (!e.available) {
                puts("not available");
                abort();
            }
            return e;
        }
    }

    abort();
}

static int xsave_fullsize;

static void init_offset() {
    uint64_t xcr0 = _xgetbv(0);
    for (auto &&e : offset_table) {
        if (xcr0 & (1ULL << e.bitpos)) {
            unsigned int eax, ebx, ecx, edx;
            __cpuid_count(0x0d, e.bitpos, eax, ebx, ecx, edx);

            if (e.bitpos == 0) {
                // x87
                xsave_fullsize = ebx;
                e.bytepos = 0;
                e.bytesize = 160;
                e.available = true;
            } else if (e.bitpos == 1) {
                // sse
                e.bytepos = 160;
                e.bytesize = 16 * 16;
                e.available = true;

            } else {
                e.bytepos = ebx;
                e.bytesize = eax;
                e.available = true;
            }
        }
    }

    printf("xsave context size = %d\n", xsave_fullsize);

    for (auto &&e : offset_table) {
        if (e.available) {
            printf("%16s (%4d): offset=%d, size=%d\n", e.name.c_str(), e.bitpos,
                   e.bytepos, e.bytesize);
        }
    }
}

#define SET_YMM(off, v) \
    asm volatile("vmovdqu %0, %%ymm" #off ::"x"(v) : "ymm" #off);

#define GET_YMM(off, v) \
    asm volatile("vmovdqu %%ymm" #off ",%0" :"=x"(v) :: "ymm" #off);

static void *alloc(size_t sz) {
    void *p;
    posix_memalign(&p, 64, sz);
    return p;
}

static void dump_xsave_header(char *p) {
    uint64_t *header = (uint64_t *)(p + 512);

    printf("XSTATE_BV : %016llx\n", (long long)header[0]);
    //printf("XCOMP_BV  : %016llx\n", (long long)header[1]);
}

int main() {
    init_offset();

    char *area = (char *)alloc(xsave_fullsize);
    memset(area, 0, xsave_fullsize);

    _xsave((void *)area, ~0ULL);
    dump_xsave_header(area);

    SET_YMM(0, _mm256_set1_epi8(1));

    _xsave((void *)area, ~0ULL);
    dump_xsave_header(area);

    return 0;
}
```




# å‚è€ƒ
Intel SDM Vol1 Chapter 13 ãŒä¸€ç•ªå‚è€ƒã«ãªã‚‹ã¨æ€ã„ã¾ã™
